import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export const packageRoot = path.resolve(__dirname, '..');
export const projectRoot = path.resolve(packageRoot, '..', '..');
export const resourcesRoot = path.join(projectRoot, 'resources', 'i18n');
export const generatedPath = path.join(packageRoot, 'src', 'generated.ts');
export const generatedTypesPath = path.join(packageRoot, 'src', 'generated-keys.d.ts');

const ANSI = {
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  green: '\x1b[32m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m',
};

function paint(color, text) {
  return `${ANSI[color]}${text}${ANSI.reset}`;
}

export function info(text) {
  console.log(paint('cyan', text));
}

export function success(text) {
  console.log(paint('green', text));
}

export function warn(text) {
  console.log(paint('yellow', text));
}

export function fail(text) {
  console.error(paint('red', text));
}

export function sorted(values) {
  return [...values].sort((a, b) => a.localeCompare(b));
}

export function flattenKeys(value, prefix = '') {
  if (typeof value !== 'object' || value === null || Array.isArray(value)) {
    return prefix ? [prefix] : [];
  }

  const entries = Object.entries(value);
  if (entries.length === 0) {
    return prefix ? [prefix] : [];
  }

  const keys = [];
  for (const [key, nested] of entries) {
    const nextPrefix = prefix ? `${prefix}.${key}` : key;
    keys.push(...flattenKeys(nested, nextPrefix));
  }
  return keys;
}

export function readJsonFile(filePath) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

export function ensureResourcesRoot() {
  if (!fs.existsSync(resourcesRoot)) {
    throw new Error(`Missing resources folder: ${resourcesRoot}`);
  }
}

export function listLocales() {
  ensureResourcesRoot();
  const locales = fs
    .readdirSync(resourcesRoot, { withFileTypes: true })
    .filter((entry) => entry.isDirectory())
    .map((entry) => entry.name);
  return sorted(locales);
}

export function resolveFallbackLocale(locales) {
  const requested = process.env.I18N_FALLBACK_LANG?.trim();
  if (requested && locales.includes(requested)) {
    return requested;
  }
  if (locales.includes('en')) {
    return 'en';
  }
  return locales[0];
}

export function listNamespaceFiles(locale) {
  const localeDir = path.join(resourcesRoot, locale);
  if (!fs.existsSync(localeDir)) {
    return [];
  }
  const namespaces = fs
    .readdirSync(localeDir, { withFileTypes: true })
    .filter((entry) => entry.isFile() && entry.name.endsWith('.json'))
    .map((entry) => entry.name.slice(0, -5));
  return sorted(namespaces);
}

export function getStructure() {
  const locales = listLocales();
  if (locales.length === 0) {
    throw new Error(`No locales found in ${resourcesRoot}`);
  }

  const fallbackLocale = resolveFallbackLocale(locales);
  const namespaces = listNamespaceFiles(fallbackLocale);
  if (namespaces.length === 0) {
    throw new Error(`No namespaces found for fallback locale "${fallbackLocale}"`);
  }

  return { locales, namespaces, fallbackLocale };
}

export function renderGeneratedContracts({ locales, namespaces }) {
  return `/* AUTO-GENERATED BY \`pnpm i18n:sync\`. DO NOT EDIT MANUALLY. */

export const I18N_LOCALES = ${JSON.stringify(locales)} as const;
export const I18N_NAMESPACES = ${JSON.stringify(namespaces)} as const;

export type I18nLocale = (typeof I18N_LOCALES)[number];
export type I18nNamespace = (typeof I18N_NAMESPACES)[number];
`;
}

export function parseGeneratedArray(source, constName) {
  const regex = new RegExp(`export const ${constName} = (\\[[^\\n]+\\]) as const;`);
  const match = source.match(regex);
  if (!match) {
    throw new Error(`Could not read ${constName} from generated.ts`);
  }
  return JSON.parse(match[1]);
}

export function readGeneratedContracts() {
  if (!fs.existsSync(generatedPath)) {
    throw new Error(`Missing generated contracts file: ${generatedPath}`);
  }
  const source = fs.readFileSync(generatedPath, 'utf8');
  return {
    locales: parseGeneratedArray(source, 'I18N_LOCALES'),
    namespaces: parseGeneratedArray(source, 'I18N_NAMESPACES'),
  };
}

export function writeTextFile(filePath, content) {
  fs.writeFileSync(filePath, `${content.trimEnd()}\n`, 'utf8');
}

export function readLocaleNamespaceJson(locale, namespace) {
  const filePath = path.join(resourcesRoot, locale, `${namespace}.json`);
  if (!fs.existsSync(filePath)) {
    throw new Error(`Missing file: ${path.relative(projectRoot, filePath)}`);
  }
  return readJsonFile(filePath);
}
